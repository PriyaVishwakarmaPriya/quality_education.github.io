<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>os</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Baloo+Bhai+2:wght@700&family=Satisfy&family=Shizuru&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Cookie&family=Kaushan+Script&family=Lavishly+Yours&family=Oleo+Script:wght@700&family=Rubik+Puddles&family=Satisfy&family=Tangerine:wght@700&family=Updock&family=Yellowtail&display=swap');
       body{
            margin:0px;
            padding:0px;
            background-color:darkseagreen;
            font-family: 'Baloo Bhai 2', cursive;
        }
    
        
        

        .left{
           /* border:4px solid royalblue;*/
            display: inline-block;
            position:absolute;
            left: 40px;
            top:20px;
        }

        .mid{
           /* border:4px solid rgb(225, 65, 201);*/
            display: block;
            width:33%;
            margin:20px auto;
            top:20px;

        }
        .right{
           /* border:4px solid rgb(124, 225, 65);*/
            position:absolute;
            right: 40px;
            top:20px;
        }

        .navbar{
                 display: inline-block;
        }
        .navbar li{
                       display: inline-block;
                       font-size: 20px;
        }
        .navbar li a{
            color:black;
            text-decoration: none;
            padding: 10px 10px;
        }

        .navbar li a:hover,.navbar li a.active{
           
           color:bisque;

        }
        
        
        .left img{
            width: 110px;
            
            
        }
        .left div{
            text-align: center;
            font-size: 20px;
            font-family: 'Cookie', cursive;
font-family: 'Kaushan Script', cursive;
font-family: 'Lavishly Yours', cursive;
font-family: 'Oleo Script', cursive;
font-family: 'Rubik Puddles', cursive;
font-family: 'Satisfy', cursive;
font-family: 'Tangerine', cursive;
font-family: 'Updock', cursive;
font-family: 'Yellowtail', cursive;}
        
        .btn{
            padding:0px 10px;
            background-color: crimson;
            margin: 0px 10px;
            color: aliceblue;
            border: 2px solid black;
            border-radius: 2px;
            font-size: 15px;
            cursor: pointer;
            font-family: 'Baloo Bhai 2', cursive;
           
        }
        .btn:hover{
            background-color: wheat;
        }
        .container{
            border:4px solid rgb(29, 2, 2) ;
            padding: 30px 30px;
            margin: 60px auto;
            width: 50%;
            border-radius: 20px;
        }

        

        .container h1{
            text-align: center;
        }
        
    
        
        

     </style>  
</head>
<body>
    <header class="header">

    
        <div class="left">
       <img src="https://thumbs.dreamstime.com/b/initial-letter-qe-logo-design-vector-template-digital-abstract-circle-180420420.jpg" alt="">
         <div>Quality Education</div>
        </div>
        <div class="mid">
           <ul type="disc"class="navbar">
               <li><a href="home.html">Home</a></li>
               <li><a>About Us </a></li>
               <li><a>Center</a></li>
               <li><a>Contact Us</a></li>
           </ul>
        </div>
   
        <div class="right">
    <button class="btn"><a href="#">Call Us Now</a></button><button class="btn"><a href="#">E-mail Us</a></button>
        </div>
    </header>
    <div>
        <div><h1 style="font-size: 30px; text-align: center;display: block;">OPERATING SYSTEM</h1></div>
        <div><h3 style="color: red;">Defination:</h3><p>An operating system is a program that controls the execution of application programs and acts as an interface between the user of a computer and the computer hardware.</p></div>
        <div><h3 style="color: royalblue;">Functions of Operating system -</h3></div>
        <div><h3 style="color: darkgreen ;">Convenience:</h3><p>An OS makes a computer more convenient to use.</p></div>
        <div><h3 style="color: darkgreen ;">Efficiency:</h3><p>An OS allows the computer system resources to be used efficiently.</p></div>
        <div><h3 style="color: darkgreen ;">Ability to Evolve:</h3><p>An OS should be constructed in such a way as to permit the effective development, testing, and introduction of new system functions at the same time without interfering with service.</p></div>
        <div><h3 style="color: darkgreen ;">Throughput:</h3><p> An OS should be constructed so that It can give maximum throughput(Number of tasks per unit time).</p></div>
        <div><h3 style="color: royalblue;">Major Functionalities of Operating System: </h3></div>       
        <div><h3 style="color: darkgreen ;">Resource Management:</h3><p>When parallel accessing happens in the OS means when multiple users are accessing the system the OS works as Resource Manager, Its responsibility is to provide hardware to the user. It decreases the load in the system.</p></div>
        <div><h3 style="color: darkgreen ;">Process Management: </h3><p>It includes various tasks like scheduling, termination of the process. OS manages various tasks at a time. Here CPU Scheduling happens means all the tasks would be done by the many algorithms that use for scheduling.</p></div>
        <div><h3 style="color: darkgreen ;">Storage Management: </h3><p>he file system mechanism used for the management of the storage. NIFS, CFS, CIFS, NFS, etc. are some file systems. All the data stores in various tracks of Hard disks that all managed by the storage manager. It included Hard Disk.</p></div>
        <div><h3 style="color: darkgreen ;">Memory Management: </h3><p> Refers to the management of primary memory. The operating system has to keep track, how much memory has been used and by whom. It has to decide which process needs memory space and how much. OS also has to allocate and deallocate the memory space.</p></div>
        <div><h3 style="color: royalblue;">Types of Operating System : </h3></div> 
        <div><h3 style="color: darkgreen ;">Batch Operating System-</h3><p>This type of operating system does not interact with the computer directly. There is an operator which takes similar jobs having the same requirement and group them into batches. It is the responsibility of the operator to sort jobs with similar needs. </p></div>
        <div><h3 style="color: darkgreen ;">Time-sharing operating System- </h3><p>Each task is given some time to execute so that all the tasks work smoothly. Each user gets the time of CPU as they use a single system. These systems are also known as Multitasking Systems. The task can be from a single user or different users also. The time that each task gets to execute is called quantum. After this time interval is over OS switches over to the next task. </p></div>
        <div><h3 style="color: darkgreen ;">Distributed operating System- </h3><p>These types of the operating system is a recent advancement in the world of computer technology and are being widely accepted all over the world and, that too, with a great pace. Various autonomous interconnected computers communicate with each other using a shared communication network</p></div>
        <div><h3 style="color: darkgreen ;">Network operating system-</h3><p>These systems run on a server and provide the capability to manage data, users, groups, security, applications, and other networking functions. These types of operating systems allow shared access of files, printers, security, applications, and other networking functions over a small private network.</p></div>
        <div><h3 style="color: darkgreen ;">Real-time operating system </h3><p>These types of OSs serve real-time systems. The time interval required to process and respond to inputs is very small. This time interval is called response time. </p></div>
        <div><h3 style="color: red ;">Process </h3><p>a process is the instance of a computer program that is being executed by one or many threads. </p></div>
        <div><h3 style="color: royalblue;">States of a Process in Operating Systems-</h3></div>
        <div><h3 style="color: darkgreen ;">New (Create)</h3><p>In this step, the process is about to be created but not yet created, it is the program which is present in secondary memory that will be picked up by OS to create the process.</p></div>
        <div><h3 style="color: darkgreen ;">Ready </h3><p>After the creation of a process, the process enters the ready state i.e. the process is loaded into the main memory. The process here is ready to run and is waiting to get the CPU time for its execution. Processes that are ready for execution by the CPU are maintained in a queue for ready processes.</p></div>
        <div><h3 style="color: darkgreen ;">Run</h3><p>The process is chosen by CPU for execution and the instructions within the process are executed by any one of the available CPU cores.</p></div>
        <div><h3 style="color: darkgreen ;">Blocked or wait</h3><p>Whenever the process requests access to I/O or needs input from the user or needs access to a critical region(the lock for which is already acquired) it enters the blocked or wait state. The process continues to wait in the main memory and does not require CPU. Once the I/O operation is completed the process goes to the ready state.</p></div>
        <div><h3 style="color: darkgreen ;">Terminated or completed</h3><p>Process is killed as well as PCB is deleted.</p></div>
        <div><h3 style="color: darkgreen ;">Suspend ready</h3><p>Process that was initially in the ready state but was swapped out of main memory(refer Virtual Memory topic) and placed onto external storage by scheduler is said to be in suspend ready state. The process will transition back to ready state whenever the process is again brought onto the main memory.</p></div>
        <div><h3 style="color: darkgreen ;">Suspend wait or suspend blocked</h3><p>Similar to suspend ready but uses the process which was performing I/O operation and lack of main memory caused them to move to secondary memory. When work is finished it may go to suspend ready. </p></div>
        <div><h3 style="color: red ;">CPU and I/O Bound Processes: </h3><p>If the process is intensive in terms of CPU operations then it is called CPU bound process. Similarly, If the process is intensive in terms of I/O operations then it is called I/O bound process.</p></div>
        <div><h3 style="color: royalblue;">Types of schedulers-</h3></div>
        <div><h3 style="color: darkgreen ;">Long term performance</h3><p> Makes a decision about how many processes should be made to stay in the ready state, this decides the degree of multiprogramming. Once a decision is taken it lasts for a long time hence called long term scheduler.</p></div>
        <div><h3 style="color: darkgreen ;">Short term  Context switching time</h3><p>Short term scheduler will decide which process to be executed next and then it will call dispatcher. A dispatcher is a software that moves process from ready to run and vice versa. In other words, it is context switching.</p></div>
        <div><h3 style="color: darkgreen ;">Medium term  Swapping time </h3><p>Suspension decision is taken by medium term scheduler. Medium term scheduler is used for swapping that is moving the process from main memory to secondary and vice versa.</p></div>
        <div><h3 style="color: royalblue;">Multiprogramming </h3><p>We have many processes ready to run. There are two types of multiprogramming:</p></div>
        <div><h3 style="color: darkgreen ;">Pre-emption </h3><p>Process is forcefully removed from CPU. Pre-emption is also called as time sharing or multitasking.</p></div>
        <div><h3 style="color: darkgreen ;">Non pre-emption </h3><p>Processes are not removed until they complete the execution.</p></div>
        
        <div><h3 style="color: red ;">CPU Scheduling in Operating Systems </h3><p>Scheduling of processes/work is done to finish the work on time. CPU Scheduling is a process that allows one process to use the CPU while another process is delayed (in standby) due to unavailability of any resources such as I / O etc, thus making full use of the CPU. The purpose of CPU Scheduling is to make the system more efficient, faster, and fairer.</p></div>
        <div><h3 style="color: royalblue;"> Different terminologies to take care of in any CPU Scheduling algorithm-</h3>
        <div><h3 style="color: darkgreen ;">Arrival Time:</h3><p>Time at which the process arrives in the ready queue.</p></div>
        <div><h3 style="color: darkgreen ;">Completion Time: </h3><p>Time at which process completes its execution.</p></div>
        <div><h3 style="color: darkgreen ;">Burst Time:</h3><p> Time required by a process for CPU execution.</p></div>
        <div><h3 style="color: darkgreen ;">Turn Around Time:</h3><p>Time Difference between completion time and arrival time.</p></div>
        <div><h3 style="color: darkgreen ;">Waiting Time(W.T): </h3><p>Time Difference between turn around time and burst time.</p></div>
        <div><h3 style="color: royalblue;"> CPU scheduling algorithms in operating systems are-</h3>
        <div><h3 style="color: darkgreen ;">First Come First Serve: </h3><p>FCFS considered to be the simplest of all operating system scheduling algorithms. First come first serve scheduling algorithm states that the process that requests the CPU first is allocated the CPU first and is implemented by using FIFO queue.</p></div>
        <div><h3 style="color: darkgreen ;">Shortest Job First(SJF):</h3><p>Shortest job first (SJF) is a scheduling process that selects the waiting process with the smallest execution time to execute next. This scheduling method may or may not be preemptive. Significantly reduces the average waiting time for other processes waiting to be executed. The full form of SJF is Shortest Job First.</p></div>
        <div><h3 style="color: darkgreen ;">Longest Job First(LJF):</h3><p>Longest Job First(LJF) scheduling process is just opposite of shortest job first (SJF), as the name suggests this algorithm is based upon the fact that the process with the largest burst time is processed first. Longest Job First is non-preemptive in nature.</p></div>
        <div><h3 style="color: darkgreen ;">Priority Scheduling:</h3><p>Preemptive Priority CPU Scheduling Algorithm is a pre-emptive method of CPU scheduling algorithm that works based on the priority of a process. In this algorithm, the editor sets the functions to be as important, meaning that the most important process must be done first. In the case of any conflict, that is, where there are more than one processor with equal value, then the most important CPU planning algorithm works on the basis of the FCFS (First Come First Serve) algorithm.</p></div>
        <div><h3 style="color: darkgreen ;"> Round robin:</h3><p>Round Robin is a CPU scheduling algorithm where each process is cyclically assigned a fixed time slot. It is the preemptive version of First come First Serve CPU Scheduling algorithm. Round Robin CPU Algorithm generally focuses on Time Sharing technique. </p></div>
        <div><h3 style="color: darkgreen ;">Shortest Remaining Time First:</h3><p>Shortest remaining time first is the preemptive version of the Shortest job first which we have discussed earlier where the processor is allocated to the job closest to completion. In SRTF the process with the smallest amount of time remaining until completion is selected to execute.</p></div>
        <div><h3 style="color: darkgreen ;">Longest Remaining Time First:</h3><p>The longest remaining time first is a preemptive version of the longest job first scheduling algorithm. This scheduling algorithm is used by the operating system to program incoming processes for use in a systematic way. This algorithm schedules those processes first which have the longest processing time remaining for completion.</p></div>
        <div><h3 style="color: darkgreen ;">Highest Response Ratio Next:</h3><p>Highest Response Ratio Next is a non-preemptive CPU Scheduling algorithm and it is considered as one of the most optimal scheduling algorithms. The name itself states that we need to find the response ratio of all available processes and select the one with the highest Response Ratio. A process once selected will run till completion. </p></div>
        <div><h3 style="color: darkgreen ;"> Multiple Queue Scheduling:</h3><p>Processes in the ready queue can be divided into different classes where each class has its own scheduling needs. For example, a common division is a foreground (interactive) process and a background (batch) process. These two classes have different scheduling needs. For this kind of situation Multilevel Queue Scheduling is used. </p></div>
        <div><h3 style="color: darkgreen ;">Multilevel Feedback Queue Scheduling:</h3><p>Multilevel Feedback Queue Scheduling (MLFQ) CPU Scheduling is like  Multilevel Queue Scheduling but in this process can move between the queues. And thus, much more efficient than multilevel queue scheduling.</p></div>
        <div><h3 style="color: red ;">Process Synchronization</h3><p>On the basis of synchronization, processes are categorized as one of the following two types:</p></div>
        <div><h3 style="color: darkgreen ;">Independent Process:</h3><p>The execution of one process does not affect the execution of other processes.</p></div>
        <div><h3 style="color: darkgreen ;">Cooperative Process:</h3><p>A process that can affect or be affected by other processes executing in the system.</p></div>
        
        <div><h3 style="color: red ;">Race Condition:</h3><p>When more than one process is executing the same code or accessing the same memory or any shared variable in that condition there is a possibility that the output or the value of the shared variable is wrong so for that all the processes doing the race to say that my output is correct this condition known as a race condition.</p></div>
        <div><h3 style="color: red ;">Critical Section Problem: </h3><p>A critical section is a code segment that can be accessed by only one process at a time. The critical section contains shared variables that need to be synchronized to maintain the consistency of data variables.</p></div>
        <div><h3 style="color: royalblue;">Any solution to the critical section problem must satisfy three requirements:</h3>
        <div><h3 style="color: darkgreen ;">Mutual Exclusion:</h3><p>If a process is executing in its critical section, then no other process is allowed to execute in the critical section.</p></div>
        <div><h3 style="color: darkgreen ;">Progress:</h3><p>If no process is executing in the critical section and other processes are waiting outside the critical section, then only those processes that are not executing in their remainder section can participate in deciding which will enter in the critical section next, and the selection can not be postponed indefinitely.</p></div>
        <div><h3 style="color: darkgreen ;">Bounded Waiting:</h3><p>A bound must exist on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.</p></div>
        <div><h3 style="color: royalblue;">Peterson's Solution: </h3><p>Peterson's Solution is a classical software-based solution to the critical section problem. In Peterson's solution, we have two shared variables:</p> <p>boolean flag[i]: Initialized to FALSE, initially no one is interested in entering the critical section</p><p>int turn: The process whose turn is to enter the critical section.</p><p style="color:blueviolet ;text-align: center;">do{</p><p style="color:blueviolet ;text-align: center;">flag[i]=True;</p><p style="color:blueviolet ;text-align: center;">turn=j;</p><p style="color:blueviolet ;text-align: center;">while(flag==j && turn==j);</p><p style="color:blueviolet ;text-align: center;">critical section;</p><p style="color:blueviolet ;text-align: center;">flag[i]=false;</p><p style="color:blueviolet ;text-align: center;">remainder section</p><p style="color:blueviolet ;text-align: center;">}while(true);</p></div>
        <div><h3 style="color: royalblue;">Semaphores:</h3><p>A semaphore is a signaling mechanism and a thread that is waiting on a semaphore can be signaled by another thread. This is different than a mutex as the mutex can be signaled only by the thread that is called the wait function.A semaphore uses two atomic operations, wait and signal for process synchronization.A Semaphore is an integer variable, which can be accessed only through two operations wait() and signal().There are two types of semaphores: Binary Semaphores and Counting Semaphores.</p></div>
        <div><h3 style="color: darkgreen ;">Binary Semaphores: </h3><p>They can only be either 0 or 1. They are also known as mutex locks, as the locks can provide mutual exclusion. All the processes can share the same mutex semaphore that is initialized to 1. Then, a process has to wait until the lock becomes 0. Then, the process can make the mutex semaphore 1 and start its critical section. When it completes its critical section, it can reset the value of the mutex semaphore to 0 and some other process can enter its critical section.</p></div>
        <div><h3 style="color: darkgreen ;">Counting Semaphores: </h3><p>They can have any value and are not restricted over a certain domain. They can be used to control access to a resource that has a limitation on the number of simultaneous accesses. The semaphore can be initialized to the number of instances of the resource. Whenever a process wants to use that resource, it checks if the number of remaining instances is more than zero, i.e., the process has an instance available. Then, the process can enter its critical section thereby decreasing the value of the counting semaphore by 1. After the process is over with the use of the instance of the resource, it can leave the critical section thereby adding 1 to the number of available instances of the resource.</p></div>
        
        <div><h3 style="color: red ;">Deadlock</h3><p>Deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process. </p></div>
        <div><h3 style="color: royalblue;">Deadlock can arise if the following four conditions hold simultaneously</h3></div>
        <div><h3 style="color: darkgreen ;">Mutual Exclusion:</h3><p>Two or more resources are non-shareable (Only one process can use at a time) </p></div>
        <div><h3 style="color: darkgreen ;">Hold and Wait:</h3><p>A process is holding at least one resource and waiting for resources. </p></div>
        <div><h3 style="color: darkgreen ;">No Preemption:</h3><p>A resource cannot be taken from a process unless the process releases the resource. </p></div>
        <div><h3 style="color: darkgreen ;">Circular Wait: </h3><p>A set of processes are waiting for each other in circular form.</p></div>
        <div><h3 style="color: royalblue;">There are three ways to handle deadlock </h3></div>  
        <div><h3 style="color: darkgreen ;">Deadlock prevention or avoidance: </h3><p>The idea is to not let the system into a deadlock state.  One can zoom into each category individually, Prevention is done by negating one of above mentioned necessary conditions for deadlock. </p></div>
        <div><h3 style="color: darkgreen ;">Deadlock detection and recovery:</h3><p>Let deadlock occur, then do preemption to handle it once occurred. </p></div>
        <div><h3 style="color: darkgreen ;"> Ignore:</h3><p>If deadlock is very rare, then let it happen and reboot the system. This is the approach that both Windows and UNIX take. </p></div>
        <div><h3 style="color: red ;">Memory Management</h3><p>In operating systems, Memory Management is the function responsible for allocating and managing a computer’s main memory. Memory Management function keeps track of the status of each memory location, either allocated or free to ensure effective and efficient use of Primary Memory. There are two Memory Management Techniques: Contiguous, and Non-Contiguous. In Contiguous Technique, executing process must be loaded entirely in the main memory.  </p></div>
        <div><h3 style="color: royalblue ;">Contiguous Technique can be divided into:</h3><p></p></div>
        <div><h3 style="color: darkgreen ;">Fixed Partitioning:</h3><p>This is the oldest and simplest technique used to put more than one process in the main memory. In this partitioning, the number of partitions (non-overlapping) in RAM is fixed but the size of each partition may or may not be the same. As it is a contiguous allocation, hence no spanning is allowed. Here partitions are made before execution or during system configure. </p></div>
        <div><h3 style="color: darkgreen ;">Variable Partitioning :</h3><p>It is a part of Contiguous allocation technique. It is used to alleviate the problem faced by Fixed Partitioning. In contrast with fixed partitioning, partitions are not made before the execution or during system configure.Initially RAM is empty and partitions are made during the run-time according to process’s need instead of partitioning during system configure.The size of partition will be equal to incoming process.The partition size varies according to the need of the process so that the internal fragmentation can be avoided to ensure efficient utilisation of RAM.Number of partitions in RAM is not fixed and depends on the number of incoming process and Main Memory's size.</p></div>
        <div><h3 style="color: royalblue ;">Non Contiguous Technique can be divided into:</h3><p></p></div>
        <div><h3 style="color: darkgreen ;">Paging: </h3><p>Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. This scheme permits the physical address space of a process to be non – contiguous.</p></div>
        <div><h3 style="color: darkgreen ;">Segmentation</h3><p>A process is divided into Segments. The chunks that a program is divided into which are not necessarily all of the same sizes are called segments. Segmentation gives user’s view of the process which paging does not give. Here the user’s view is mapped to physical memory.</p></div>
        <div><h3 style="color: red ;">Disk Scheduling</h3><p>Disk scheduling is done by operating systems to schedule I/O requests arriving for the disk. Disk scheduling is also known as I/O scheduling. </p></div>
       <!-- <div><h3 style="color: darkgreen ;"></h3><p></p></div>-->
        
        <!--<div><h3 style="color: red ;"></h3><p></p></div>-->
        
        <div><h3 style="color: royalblue ;">There are many Disk Scheduling Algorithms but before discussing them let’s have a quick look at some of the important terms: </h3></div>
        <!--<div><h3 style="color: royalblue ;"></h3><p></p></div>-->
        <div><h3 style="color: darkgreen ;">Seek Time:</h3><p>Seek time is the time taken to locate the disk arm to a specified track where the data is to be read or write. So the disk scheduling algorithm that gives minimum average seek time is better.</p></div>
        <div><h3 style="color: darkgreen ;">Rotational Latency: </h3><p>Rotational Latency is the time taken by the desired sector of disk to rotate into a position so that it can access the read/write heads. So the disk scheduling algorithm that gives minimum rotational latency is better.</p></div>
        <div><h3 style="color: darkgreen ;">Transfer Time:</h3><p>Transfer time is the time to transfer the data. It depends on the rotating speed of the disk and number of bytes to be transferred.</p></div>
        <div><h3 style="color: darkgreen ;">Disk Access Time:</h3><p> Disk Access Time = Seek Time +  Rotational Latency +  Transfer Time</p></div>
        <div><h1 style="color:palevioletred;text-align: center;">************</h1>
  
  
  
    </div>
    </body>
    </html> 